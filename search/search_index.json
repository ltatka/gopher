{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gopher: Fast GO Enrichment for Quantitative Proteomic Data","text":"<p>Gopher uses a Mann-Whitney U Test to look for enriched gene ontology terms that are present when proteins are ranked by a quantitative value, such as the fold change between two conditions or the abundance of the protein.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>Gopher be pip installed using:</p> <pre><code>pip install gopher-enrich\n</code></pre>"},{"location":"api/","title":"API","text":"<p>Read results from EncyclopeDIA.</p> <p>Read results from Metamorpheus.</p> <p>Test for the enrichment of Gene Ontology terms from protein abundance.</p> <p>The Mann-Whitney U Test is applied to each column of proteins dataframe and for each Gene Ontology (GO) term. The p-values are then corrected for multiple hypothesis testing across all of the columns using the Benjamini-Hochberg procedure.</p> <p>Retrieve the current data directory for ppx.</p> Source code in <code>gopher/config.py</code> <pre><code>def get_data_dir():\n    \"\"\"Retrieve the current data directory for ppx.\"\"\"\n    return config.path\n</code></pre> <p>Set the ppx data directory.</p> <p>Generate an annotation file for a list of proteins that are correlated to a single term and aspect.</p> <p>The term can be in the GO database or a new term.</p> <p>Load the Gene Ontology (GO) annotations for a species.</p> <p>Gets the annotations for proteins in a dataset</p> <p>Map the proteins to the GO terms</p> <p>Normalize intensity values.</p> <p>Normalize using the proteomic ruler approach outlined by Wi\u015bniewski et al. (doi: https://doi.org/10.1074/mcp.M113.037309)</p> <p>Rank the proteins and show whether proteins are in a specified term</p> <p>See if proteins are associated with a specific term</p> <p>Plot the ROC curve for a go term in each sample</p>"},{"location":"api/#gopher.read_encyclopedia--parameters","title":"Parameters","text":"<p>proteins_txt : str     The EncyclopeDIA protein output.</p>"},{"location":"api/#gopher.read_encyclopedia--returns","title":"Returns","text":"<p>pandas.DataFrame     The EncyclopeDIA results in a format for gopher.</p> Source code in <code>gopher/parsers/tabular.py</code> <pre><code>def read_encyclopedia(proteins_txt: str) -&gt; pd.DataFrame:\n    \"\"\"Read results from EncyclopeDIA.\n\n    Parameters\n    ----------\n    proteins_txt : str\n        The EncyclopeDIA protein output.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The EncyclopeDIA results in a format for gopher.\n    \"\"\"\n    proteins = pd.read_table(proteins_txt)\n    accessions = proteins[\"Protein\"].str.extract(r\"\\|(.+?)\\|\", expand=False)\n\n    proteins = proteins.set_index(accessions)\n    return proteins.drop(\n        columns=[\"Protein\", \"NumPeptides\", \"PeptideSequences\"]\n    )\n</code></pre>"},{"location":"api/#gopher.read_metamorpheus--parameters","title":"Parameters","text":"<p>proteins_txt : str     The Metamorpheus protein output file.</p>"},{"location":"api/#gopher.read_metamorpheus--returns","title":"Returns","text":"<p>pandas.DataFrame     The Metamorpheus results in a format for gopher.</p> Source code in <code>gopher/parsers/tabular.py</code> <pre><code>def read_metamorpheus(proteins_txt: str) -&gt; pd.DataFrame:\n    \"\"\"Read results from Metamorpheus.\n\n    Parameters\n    ----------\n    proteins_txt : str\n        The Metamorpheus protein output file.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The Metamorpheus results in a format for gopher.\n    \"\"\"\n    proteins = pd.read_table(proteins_txt, low_memory=False)\n    accessions = proteins[\"Protein\"].str.extract(\n        r\"^(.*?)(\\||$)\", expand=False\n    )[0]\n    accessions.name = \"Protein\"\n    int_cols = [c for c in proteins.columns if c.startswith(\"Intensity\")]\n    proteins = proteins.set_index(accessions)\n    proteins = (\n        proteins.loc[\n            proteins[\"Protein Decoy/Contaminant/Target\"] == \"T\", int_cols\n        ]\n        .apply(pd.to_numeric)\n        .fillna(0)\n    )\n    return proteins\n</code></pre>"},{"location":"api/#gopher.test_enrichment--parameters","title":"Parameters","text":"<p>proteins : pandas.DataFrame     A dataframe where the indices are UniProt accessions and each column is     an experiment to test. The values in this dataframe should be some     measure of protein abundance: these could be the raw measurement if     originating from a single sample or a fold-change/p-value if looking at     the difference between two conditions. desc : bool, optional     Rank proteins in descending order? aspect : str, {\u201ccc\u201d, \u201cmf\u201d, \u201cbp\u201d, \u201call\u201d}, optional     The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d,     \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d     for all three. species : str, {\u201chuman\u201d, \u201cyeast\u201d, \u2026}, optional.     The species for which to retrieve GO annotations. If not \u201chuman\u201d or     \u201cyeast\u201d, see     here. release : str, optional     The Gene Ontology release version. Using \u201ccurrent\u201d will look up the     most current version. go_subset: list of str, optional     The go terms of interest. Should consists of the go term names such     as \u2018nucleus\u2019 or \u2018cytoplasm\u2019. contaminants_filter: List[str], optional     A list of uniprot accessions for common contaminants such as     Keratin to filter out. fetch : bool, optional     Download the GO annotations even if they have been downloaded before? progress : bool, optional     Show a progress bar during enrichment tests? annotations: pandas.DataFrame, optional     A custom annotations dataframe. mapping: defaultdict, optional     A custom mapping of the GO term relationships. aggregate_terms : bool, optional     Aggregate the terms and do the graph search. alternative : str, {\u201cgreater\u201d, \u201cless\u201d, \u201ctwo-sided\u201d} optional     Type of test that should be run.     Could be \u201cgreater\u201d, \u201cless\u201d, or \u201ctwo-sided\u201d.</p>"},{"location":"api/#gopher.test_enrichment--returns","title":"Returns","text":"<p>pandas.DataFrame     The adjusted p-value for each tested GO term in each sample.</p> Source code in <code>gopher/enrichment.py</code> <pre><code>def test_enrichment(\n    proteins: pd.DataFrame,\n    desc: bool = True,\n    aspect: str = \"all\",\n    species: str = \"human\",\n    release: str = \"current\",\n    go_subset: list = None,\n    contaminants_filter: list = None,\n    fetch: bool = False,\n    progress: bool = False,\n    annotations: pd.DataFrame = None,\n    mapping: dict = None,\n    aggregate_terms: bool = True,\n    alternative: str = \"greater\",\n):\n    \"\"\"Test for the enrichment of Gene Ontology terms from protein abundance.\n\n    The Mann-Whitney U Test is applied to each column of proteins dataframe and\n    for each Gene Ontology (GO) term. The p-values are then corrected for\n    multiple hypothesis testing across all of the columns using the\n    Benjamini-Hochberg procedure.\n\n    Parameters\n    ----------\n    proteins : pandas.DataFrame\n        A dataframe where the indices are UniProt accessions and each column is\n        an experiment to test. The values in this dataframe should be some\n        measure of protein abundance: these could be the raw measurement if\n        originating from a single sample or a fold-change/p-value if looking at\n        the difference between two conditions.\n    desc : bool, optional\n        Rank proteins in descending order?\n    aspect : str, {\"cc\", \"mf\", \"bp\", \"all\"}, optional\n        The Gene Ontology aspect to use. Use \"cc\" for \"Cellular Compartment\",\n        \"mf\" for \"Molecular Function\", \"bp\" for \"Biological Process\", or \"all\"\n        for all three.\n    species : str, {\"human\", \"yeast\", ...}, optional.\n        The species for which to retrieve GO annotations. If not \"human\" or\n        \"yeast\", see\n        [here](http://current.geneontology.org/products/pages/downloads.html).\n    release : str, optional\n        The Gene Ontology release version. Using \"current\" will look up the\n        most current version.\n    go_subset: list of str, optional\n        The go terms of interest. Should consists of the go term names such\n        as 'nucleus' or 'cytoplasm'.\n    contaminants_filter: List[str], optional\n        A list of uniprot accessions for common contaminants such as\n        Keratin to filter out.\n    fetch : bool, optional\n        Download the GO annotations even if they have been downloaded before?\n    progress : bool, optional\n        Show a progress bar during enrichment tests?\n    annotations: pandas.DataFrame, optional\n        A custom annotations dataframe.\n    mapping: defaultdict, optional\n        A custom mapping of the GO term relationships.\n    aggregate_terms : bool, optional\n        Aggregate the terms and do the graph search.\n    alternative : str, {\"greater\", \"less\", \"two-sided\"} optional\n        Type of test that should be run.\n        Could be \"greater\", \"less\", or \"two-sided\".\n\n    Returns\n    -------\n    pandas.DataFrame\n        The adjusted p-value for each tested GO term in each sample.\n    \"\"\"\n    LOGGER.info(\"Retrieving GO annotations...\")\n\n    if annotations is not None:\n        annot = annotations\n    else:\n        annot, map = load_annotations(\n            species=species,\n            aspect=aspect,\n            release=release,\n            fetch=fetch,\n        )\n        if not mapping:\n            mapping = map\n\n    if go_subset:\n        if aggregate_terms and mapping:\n            annot = graph_search(mapping, go_subset, annot)\n\n        in_names = annot[\"go_name\"].isin(go_subset)\n        in_ids = annot[\"go_id\"].isin(go_subset)\n        annot = annot.loc[in_names | in_ids, :]\n\n    accessions = pd.DataFrame(\n        list(proteins.index),\n        columns=[\"uniprot_accession\"],\n    )\n    if contaminants_filter:\n        accessions = accessions[\n            ~accessions[\"uniprot_accession\"].isin(contaminants_filter)\n        ]\n\n    # Get the GO terms and proteins\n    annot = accessions.merge(annot, how=\"inner\")\n    n_prot = proteins.shape[1]\n    proteins = pd.DataFrame(proteins).loc[annot[\"uniprot_accession\"], :]\n    lost = n_prot - proteins.shape[1]\n    if lost:\n        LOGGER.warning(\"%i proteins not found in GO annotations.\", lost)\n\n    if not desc:\n        proteins = -proteins\n\n    results = []\n    grp_cols = [\"go_id\", \"go_name\", \"aspect\"]\n\n    LOGGER.info(\"Testing enrichment...\")\n    for term, accessions in tqdm(\n        annot.groupby(grp_cols), disable=not progress\n    ):\n        in_term = proteins.index.isin(accessions[\"uniprot_accession\"].unique())\n        in_vals = proteins[in_term].to_numpy()\n        out_vals = proteins[~in_term].to_numpy()\n        res = mannwhitneyu(in_vals, out_vals, alternative)\n        if res != None:\n            results.append(list(term) + list(res[1]))\n\n    cols = [\"GO ID\", \"GO Name\", \"GO Aspect\"] + list(proteins.columns)\n    results = pd.DataFrame(results, columns=cols)\n    results.loc[:, proteins.columns] = results.loc[:, proteins.columns].apply(\n        adjust_pvals, raw=True\n    )\n\n    return results\n</code></pre>"},{"location":"api/#gopher.set_data_dir--parameters","title":"Parameters","text":"<p>path : str or pathlib.Path object, optional     The path for ppx to use as its data directory.</p> Source code in <code>gopher/config.py</code> <pre><code>def set_data_dir(path: str = None):\n    \"\"\"Set the ppx data directory.\n\n    Parameters\n    ----------\n    path : str or pathlib.Path object, optional\n        The path for ppx to use as its data directory.\n    \"\"\"\n    config.path = path\n</code></pre>"},{"location":"api/#gopher.generate_annotations--parameters","title":"Parameters","text":"<p>proteins : List[str]     List of proteins (UniProtKB accessions) that will be annotated to a term. aspect: str     String specifying the aspect the term is in (\u201cC\u201d, \u201cF\u201d, \u201cP\u201d). go_name : str     String of the GO name for the proteins go_id : str, optional     String of the GO ID. If in the GO database, the go id and go name should match the database.</p>"},{"location":"api/#gopher.generate_annotations--returns","title":"Returns","text":"<p>pandas.DataFrame     An annotations dataframe with a single go term.</p> Source code in <code>gopher/annotations.py</code> <pre><code>def generate_annotations(\n    proteins: list, aspect: str, go_name: str, go_id: str = None\n) -&gt; pd.DataFrame:\n    \"\"\"Generate an annotation file for a list of proteins that are correlated to a single term and aspect.\n\n    The term can be in the GO database or a new term.\n\n    Parameters\n    ----------\n    proteins : List[str]\n        List of proteins (UniProtKB accessions) that will be annotated to a term.\n    aspect: str\n        String specifying the aspect the term is in (\"C\", \"F\", \"P\").\n    go_name : str\n        String of the GO name for the proteins\n    go_id : str, optional\n        String of the GO ID. If in the GO database, the go id and go name should match the database.\n\n    Returns\n    -------\n    pandas.DataFrame\n        An annotations dataframe with a single go term.\n    \"\"\"\n    if not go_id:\n        # Generate a unique GO ID if one is not given\n        go_id = \"GO:\" + str(uuid.uuid4().int)\n    # Create the annotations df\n    data = {\n        \"uniprot_accession\": proteins,\n        \"go_id\": go_id,\n        \"aspect\": aspect,\n        \"go_name\": go_name,\n    }\n    annot = pd.DataFrame.from_dict(data)\n    return annot\n</code></pre>"},{"location":"api/#gopher.load_annotations--parameters","title":"Parameters","text":"<p>species : str, {\u201chuman\u201d, \u201cyeast\u201d, \u2026}     The species for which to retrieve GO annotations. If not \u201chumnan\u201d or     \u201cyeast\u201d, see     here. aspect : str, {\u201ccc\u201d, \u201cmf\u201d, \u201cbp\u201d, \u201call\u201d}, optional     The Gene Ontology aspect to use. Use \u201cc\u201d for \u201cCellular Compartment\u201d,     \u201cf\u201d for \u201cMolecular Function\u201d, or \u201cp\u201d for \u201cBiological Process\u201d. <code>None</code>     uses all of the them. release: str     The Gene Ontology release version. Using \u201ccurrent\u201d will look up the     most current version. fetch : bool     Download the file even if it already exists?</p>"},{"location":"api/#gopher.load_annotations--returns","title":"Returns","text":"<p>pandas.DataFrame     The annotation dataframe. dict     A mapping of GO terms (keys) to Uniprot accessions with that     annotation.</p> Source code in <code>gopher/annotations.py</code> <pre><code>def load_annotations(\n    species: str,\n    aspect: str = \"all\",\n    release: str = \"current\",\n    fetch: bool = False,\n):\n    \"\"\"Load the Gene Ontology (GO) annotations for a species.\n\n    Parameters\n    ----------\n    species : str, {\"human\", \"yeast\", ...}\n        The species for which to retrieve GO annotations. If not \"humnan\" or\n        \"yeast\", see\n        [here](http://current.geneontology.org/products/pages/downloads.html).\n    aspect : str, {\"cc\", \"mf\", \"bp\", \"all\"}, optional\n        The Gene Ontology aspect to use. Use \"c\" for \"Cellular Compartment\",\n        \"f\" for \"Molecular Function\", or \"p\" for \"Biological Process\". ``None``\n        uses all of the them.\n    release: str\n        The Gene Ontology release version. Using \"current\" will look up the\n        most current version.\n    fetch : bool\n        Download the file even if it already exists?\n\n    Returns\n    -------\n    pandas.DataFrame\n        The annotation dataframe.\n    dict\n        A mapping of GO terms (keys) to Uniprot accessions with that\n        annotation.\n    \"\"\"\n    aspects = {\"cc\": \"C\", \"mf\": \"F\", \"bp\": \"P\", \"all\": None}\n\n    try:\n        aspect = aspects[aspect.lower()]\n    except KeyError as err:\n        raise ValueError(\n            f\"Expected apsect ({aspect}) to be one of 'cc', 'mf', 'bp', or\"\n            \" 'all'.\"\n        ) from err\n\n    cols = [\n        \"db\",\n        \"uniprot_accession\",\n        \"db_object_symbol\",\n        \"qualifier\",\n        \"go_id\",\n        \"db_reference\",\n        \"evidence_code\",\n        \"with_or_from\",\n        \"aspect\",\n        \"db_object_name\",\n        \"db_object_synonym\",\n        \"db_object_type\",\n        \"taxon\",\n        \"date\",\n        \"assigned_by\",\n        \"annotation_extension\",\n        \"gene_product_form_id\",\n    ]\n\n    terms, mapping = ontologies.load_ontology()\n    species = SPECIES.get(species.lower(), species.lower())\n    annot_file = download_annotations(species, release=release, fetch=fetch)\n    annot = pd.read_table(\n        annot_file,\n        comment=\"!\",\n        header=None,\n        names=cols,\n        low_memory=False,\n    )\n\n    if aspect is not None:\n        annot = annot.loc[annot[\"aspect\"] == aspect, :]\n\n    uniprot = annot[\"db\"] == \"UniProtKB\"\n    if not uniprot.all():\n        annot.loc[~uniprot, \"uniprot_accession\"] = annot.loc[\n            ~uniprot, \"gene_product_form_id\"\n        ].str.extract(r\"UniProtKB:(.+)\", expand=False)\n\n    keep = [\"uniprot_accession\", \"go_id\", \"aspect\"]\n    annot = annot.loc[:, keep].drop_duplicates()\n    annot[\"go_name\"] = annot[\"go_id\"].map(terms)\n    return annot, mapping\n</code></pre>"},{"location":"api/#gopher.get_annotations--parameters","title":"Parameters","text":"<p>proteins : pandas.DataFrame     Dataframe of proteins and quantifications aspect : str, {\u201ccc\u201d, \u201cmf\u201d, \u201cbp\u201d, \u201call\u201d}, optional     The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d,     \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d     for all three. species : str, {\u201chuman\u201d, \u201cyeast\u201d, \u2026}, optional.     The species for which to retrieve GO annotations. If not \u201chuman\u201d or     \u201cyeast\u201d, see     here. release : str, optional     The Gene Ontology release version. Using \u201ccurrent\u201d will look up the     most current version. fetch : bool, optional     Download the GO annotations even if they have been downloaded before? go_subset: list of str, optional     The go terms of interest. Should consists of the go term names such     as \u2018nucleus\u2019 or \u2018cytoplasm\u2019.</p>"},{"location":"api/#gopher.get_annotations--returns","title":"Returns","text":"<p>pandas.DataFrame     Dataframe with protein annotations</p> Source code in <code>gopher/display_data.py</code> <pre><code>def get_annotations(\n    proteins: pd.DataFrame,\n    aspect: str = \"all\",\n    species: str = \"human\",\n    release: str = \"current\",\n    fetch: bool = False,\n    go_subset: list = None,\n):\n    \"\"\"Gets the annotations for proteins in a dataset\n\n    Parameters\n    ----------\n    proteins : pandas.DataFrame\n        Dataframe of proteins and quantifications\n    aspect : str, {\"cc\", \"mf\", \"bp\", \"all\"}, optional\n        The Gene Ontology aspect to use. Use \"cc\" for \"Cellular Compartment\",\n        \"mf\" for \"Molecular Function\", \"bp\" for \"Biological Process\", or \"all\"\n        for all three.\n    species : str, {\"human\", \"yeast\", ...}, optional.\n        The species for which to retrieve GO annotations. If not \"human\" or\n        \"yeast\", see\n        [here](http://current.geneontology.org/products/pages/downloads.html).\n    release : str, optional\n        The Gene Ontology release version. Using \"current\" will look up the\n        most current version.\n    fetch : bool, optional\n        Download the GO annotations even if they have been downloaded before?\n    go_subset: list of str, optional\n        The go terms of interest. Should consists of the go term names such\n        as 'nucleus' or 'cytoplasm'.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Dataframe with protein annotations\n    \"\"\"\n    # Load the annotation file\n    annot, _ = load_annotations(\n        species=species,\n        aspect=aspect,\n        release=release,\n        fetch=fetch,\n    )\n\n    # If a subset of terms was given, filter for the subset\n    if go_subset:\n        in_names = annot[\"go_name\"].isin(go_subset)\n        in_ids = annot[\"go_id\"].isin(go_subset)\n        annot = annot.loc[in_names | in_ids, :]\n\n    # Filter for proteins seen in input dataframe\n    accessions = pd.DataFrame(\n        list(proteins.index),\n        columns=[\"uniprot_accession\"],\n    )\n    annot = accessions.merge(annot, how=\"inner\")\n    return annot\n</code></pre>"},{"location":"api/#gopher.map_proteins--parameters","title":"Parameters","text":"<p>protein_list : List[str]     A list of UniProt accessions. aspect : str, {\u201ccc\u201d, \u201cmf\u201d, \u201cbp\u201d, \u201call\u201d}, optional     The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d,     \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d     for all three. species : str, {\u201chuman\u201d, \u201cyeast\u201d, \u2026}, optional.     The species for which to retrieve GO annotations. If not \u201chuman\u201d or     \u201cyeast\u201d, see     here. release : str, optional     The Gene Ontology release version. Using \u201ccurrent\u201d will look up the     most current version. fetch : bool, optional     Download the GO annotations even if they have been downloaded before?</p>"},{"location":"api/#gopher.map_proteins--returns","title":"Returns","text":"<p>pandas.DataFrame     Dataframe with protein accessions and GO terms</p> Source code in <code>gopher/display_data.py</code> <pre><code>def map_proteins(\n    protein_list: list,\n    aspect: str = \"all\",\n    species: str = \"human\",\n    release: str = \"current\",\n    fetch: bool = False,\n):\n    \"\"\"Map the proteins to the GO terms\n\n    Parameters\n    ----------\n    protein_list : List[str]\n        A list of UniProt accessions.\n    aspect : str, {\"cc\", \"mf\", \"bp\", \"all\"}, optional\n        The Gene Ontology aspect to use. Use \"cc\" for \"Cellular Compartment\",\n        \"mf\" for \"Molecular Function\", \"bp\" for \"Biological Process\", or \"all\"\n        for all three.\n    species : str, {\"human\", \"yeast\", ...}, optional.\n        The species for which to retrieve GO annotations. If not \"human\" or\n        \"yeast\", see\n        [here](http://current.geneontology.org/products/pages/downloads.html).\n    release : str, optional\n        The Gene Ontology release version. Using \"current\" will look up the\n        most current version.\n    fetch : bool, optional\n        Download the GO annotations even if they have been downloaded before?\n\n    Returns\n    -------\n    pandas.DataFrame\n        Dataframe with protein accessions and GO terms\n    \"\"\"\n    # Put the protein list into a dataframe so it can be used to get the annotations\n    proteins = pd.DataFrame(index=protein_list)\n    # Get the annotations\n    annot = get_annotations(proteins, aspect, species, release, fetch)\n    # Return relevant columns\n    return annot[[\"uniprot_accession\", \"go_id\", \"go_name\"]]\n</code></pre>"},{"location":"api/#gopher.normalize_values--parameters","title":"Parameters","text":"<p>proteins : pandas.DataFrame     A dataframe where the indices are UniProt accessions and each column is     an experiment to test. The values in this dataframe raw protein abundance fasta : Path     Use the FASTA file to generate molecular weights for normalization</p>"},{"location":"api/#gopher.normalize_values--returns","title":"Returns","text":"<p>pandas.DataFrame     The normalized intensities for every protein in each sample.</p> Source code in <code>gopher/normalize.py</code> <pre><code>def normalize_values(proteins: pd.DataFrame, fasta: Path):\n    \"\"\"Normalize intensity values.\n\n    Normalize using the proteomic ruler approach outlined by Wi\u015bniewski et al.\n    (doi: https://doi.org/10.1074/mcp.M113.037309)\n\n    Parameters\n    ----------\n    proteins : pandas.DataFrame\n        A dataframe where the indices are UniProt accessions and each column is\n        an experiment to test. The values in this dataframe raw protein abundance\n    fasta : Path\n        Use the FASTA file to generate molecular weights for normalization\n\n    Returns\n    -------\n    pandas.DataFrame\n        The normalized intensities for every protein in each sample.\n    \"\"\"\n    fasta_df = read_fasta(fasta)\n    fasta_df = fasta_df.set_index(\"Protein\")\n    proteins = proteins.apply(col_norm, axis=0)\n    df = proteins.join(fasta_df)\n    df = df.drop(columns=[\"Sequence\"])\n    df = df.apply(mass_norm, axis=1)\n    df = df.drop(columns=[\"Mass\"])\n\n    return df\n</code></pre>"},{"location":"api/#gopher.get_rankings--parameters","title":"Parameters","text":"<p>proteins : pandas.DataFrame     Dataframe of protein quant data go_term : str     String of specified GO term name aspect : str, {\u201ccc\u201d, \u201cmf\u201d, \u201cbp\u201d, \u201call\u201d}, optional     The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d,     \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d     for all three. species : str, {\u201chuman\u201d, \u201cyeast\u201d, \u2026}, optional.     The species for which to retrieve GO annotations. If not \u201chuman\u201d or     \u201cyeast\u201d, see     here. release : str, optional     The Gene Ontology release version. Using \u201ccurrent\u201d will look up the     most current version. fetch : bool, optional     Download the GO annotations even if they have been downloaded before?</p>"},{"location":"api/#gopher.get_rankings--returns","title":"Returns","text":"<p>pandas.DataFrame     Dataframe with protein rankings and whether or not the protein is in the specified term</p> Source code in <code>gopher/display_data.py</code> <pre><code>def get_rankings(\n    proteins: pd.DataFrame,\n    go_term: str,\n    aspect: str = \"all\",\n    species: str = \"human\",\n    release: str = \"current\",\n    fetch: bool = False,\n):\n    \"\"\"Rank the proteins and show whether proteins are in a specified term\n\n    Parameters\n    ----------\n    proteins : pandas.DataFrame\n        Dataframe of protein quant data\n    go_term : str\n        String of specified GO term name\n    aspect : str, {\"cc\", \"mf\", \"bp\", \"all\"}, optional\n        The Gene Ontology aspect to use. Use \"cc\" for \"Cellular Compartment\",\n        \"mf\" for \"Molecular Function\", \"bp\" for \"Biological Process\", or \"all\"\n        for all three.\n    species : str, {\"human\", \"yeast\", ...}, optional.\n        The species for which to retrieve GO annotations. If not \"human\" or\n        \"yeast\", see\n        [here](http://current.geneontology.org/products/pages/downloads.html).\n    release : str, optional\n        The Gene Ontology release version. Using \"current\" will look up the\n        most current version.\n    fetch : bool, optional\n        Download the GO annotations even if they have been downloaded before?\n\n    Returns\n    -------\n    pandas.DataFrame\n        Dataframe with protein rankings and whether or not the protein is in the specified term\n    \"\"\"\n    # Get the annotations\n    annot = get_annotations(proteins, aspect, species, release, fetch)\n    # Rank the data and format it as a dataframe\n    ranked = rankdata(proteins.to_numpy())\n    ranked = pd.DataFrame(ranked, columns=proteins.columns)\n    ranked = ranked.set_index(proteins.index)\n    # Add column for if proteins are in given term and return data\n    ranked = in_term(ranked, go_term, annot).drop_duplicates()\n    return ranked\n</code></pre>"},{"location":"api/#gopher.in_term--parameters","title":"Parameters","text":"<p>proteins : pandas.DataFrame     Dataframe of proteins and quantifications go_term : str     String of specified GO term name annot : pandas.DataFrame     Annotation file for the dataset</p>"},{"location":"api/#gopher.in_term--returns","title":"Returns","text":"<p>pandas.DataFrame     Dataframe with protein quant and if protein is in the given term</p> Source code in <code>gopher/display_data.py</code> <pre><code>def in_term(proteins: pd.DataFrame, go_term: str, annot: pd.DataFrame):\n    \"\"\"See if proteins are associated with a specific term\n\n    Parameters\n    ----------\n    proteins : pandas.DataFrame\n        Dataframe of proteins and quantifications\n    go_term : str\n        String of specified GO term name\n    annot : pandas.DataFrame\n        Annotation file for the dataset\n\n    Returns\n    -------\n    pandas.DataFrame\n        Dataframe with protein quant and if protein is in the given term\n    \"\"\"\n    # Get columns of terms\n    term = annot[annot[\"go_name\"] == go_term]\n    proteins[\"in_term\"] = proteins.index.isin(\n        term[\"uniprot_accession\"].unique()\n    )\n    return proteins\n</code></pre>"},{"location":"api/#gopher.roc--parameters","title":"Parameters","text":"<p>proteins : pandas.DataFrame     Dataframe of proteins and quantifications go_term : str     String of specified GO term name aspect : str, {\u201ccc\u201d, \u201cmf\u201d, \u201cbp\u201d, \u201call\u201d}, optional     The Gene Ontology aspect to use. Use \u201ccc\u201d for \u201cCellular Compartment\u201d,     \u201cmf\u201d for \u201cMolecular Function\u201d, \u201cbp\u201d for \u201cBiological Process\u201d, or \u201call\u201d     for all three. species : str, {\u201chuman\u201d, \u201cyeast\u201d, \u2026}, optional.     The species for which to retrieve GO annotations. If not \u201chuman\u201d or     \u201cyeast\u201d, see     here. release : str, optional     The Gene Ontology release version. Using \u201ccurrent\u201d will look up the     most current version. fetch : bool, optional     Download the GO annotations even if they have been downloaded before?</p>"},{"location":"api/#gopher.roc--returns","title":"Returns","text":"<p>matplotlib.pyplot     Plot of ROC curve for a GO term</p> Source code in <code>gopher/display_data.py</code> <pre><code>def roc(\n    proteins: pd.DataFrame,\n    go_term: str,\n    aspect: str = \"all\",\n    species: str = \"human\",\n    release: str = \"current\",\n    fetch: bool = False,\n):\n    \"\"\"Plot the ROC curve for a go term in each sample\n\n    Parameters\n    ----------\n    proteins : pandas.DataFrame\n        Dataframe of proteins and quantifications\n    go_term : str\n        String of specified GO term name\n    aspect : str, {\"cc\", \"mf\", \"bp\", \"all\"}, optional\n        The Gene Ontology aspect to use. Use \"cc\" for \"Cellular Compartment\",\n        \"mf\" for \"Molecular Function\", \"bp\" for \"Biological Process\", or \"all\"\n        for all three.\n    species : str, {\"human\", \"yeast\", ...}, optional.\n        The species for which to retrieve GO annotations. If not \"human\" or\n        \"yeast\", see\n        [here](http://current.geneontology.org/products/pages/downloads.html).\n    release : str, optional\n        The Gene Ontology release version. Using \"current\" will look up the\n        most current version.\n    fetch : bool, optional\n        Download the GO annotations even if they have been downloaded before?\n\n    Returns\n    -------\n    matplotlib.pyplot\n        Plot of ROC curve for a GO term\n    \"\"\"\n    # Get a list of the samples\n    samples = proteins.columns\n    # Get annotations\n    annot = get_annotations(proteins, aspect, species, release, fetch)\n\n    # Rank the data based on the go term\n    proteins = in_term(proteins, go_term, annot)\n\n    # Get the number of positive and negative cases\n    n_pos = sum(proteins[\"in_term\"])\n    n_neg = len(proteins) - n_pos\n\n    # Set up plot\n    fig, axs = plt.subplots(1, len(samples), figsize=(13, 4.5))\n    i = 0\n\n    # Graph the ROC curve for each sample\n    for sample in samples:\n        # Sort values\n        sorted = proteins.sort_values(sample, ascending=False)\n\n        # Calculate TPR and FPR\n        sorted[\"tpr\"] = sorted[\"in_term\"].cumsum() / sorted[\"in_term\"].sum()\n        sorted[\"fpr\"] = (~sorted[\"in_term\"]).cumsum() / (\n            ~sorted[\"in_term\"]\n        ).sum()\n\n        # Need to add a point at 0, 0:\n        tpr = np.append(0, sorted[\"tpr\"])\n        fpr = np.append(0, sorted[\"fpr\"])\n\n        # Graph ROC curve\n        ax = axs[i]\n        p = sns.lineplot(x=fpr, y=tpr, drawstyle=\"steps-post\", ci=None, ax=ax)\n        sns.lineplot(\n            x=(0, 1), y=(0, 1), color=\"black\", linestyle=\"dashed\", ax=ax\n        )\n        ax.title.set_text(sample)\n        ax.set_xlabel(\"False Positive Rate (FPR)\")\n        ax.set_ylabel(\"True Positive Rate (TPR)\")\n\n        # Calculate AUC and put on graph in lower right corner\n        U, _ = stats.mannwhitneyu(\n            sorted.loc[sorted[\"in_term\"], sample],\n            sorted.loc[~sorted[\"in_term\"], sample],\n        )\n        auc = U / (n_pos * n_neg)\n        auc = \"AUC = \" + str(round(auc, 3))\n        p.annotate(auc, xy=(0.75, 0))\n\n        i += 1\n\n    # Format and return plot\n    for ax in axs:\n        ax.set(adjustable=\"box\", aspect=\"equal\")\n\n    plt.tight_layout()\n\n    return plt\n</code></pre>"},{"location":"examples/","title":"Short Examples","text":""},{"location":"examples/#basic-enrichment","title":"Basic enrichment","text":"<p>Gopher can takes a proteomic file with the UniProtKB accessions as the index and quantitative values (p-value, intensity, fold change, etc.) as the columns.</p> <p>Example input:</p> index Sample 1 Sample 2 Sample 3 P10809 3.95430112E+08 3.83382752E+08 5.11112448E+08 Q9Y6Y0 1.18023552E+09 1.24697638E+09 8.1498893E+08 \u2026 \u2026 \u2026 \u2026 <pre><code>import gopher\n\n# Perform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=quant_proteins)\n</code></pre> <p>Gopher returns a dataframe with the following columns:</p> <ul> <li>GO ID: String with the gene ontology term ID.</li> <li>GO Name: String with the gene ontology term name.</li> <li>GO Aspect: String with the gene ontology aspect. Either C (cellular component), F (molecular function), and B (biological process).</li> <li>Columns containing p-values from the GO enrichment.</li> </ul> <p>Example output: </p> GO ID GO Name GO Aspect Sample 1 Sample 2 Sample 3 GO:0000228 nuclear chromosome C 0.1271222 0.2485581 0.1503805 GO:0005737 cytoplasm C 0.5443486 0.0049575 0.0183452 GO:0009986 cell surface C 0.9657132 0.9962968 0.9997324 \u2026 \u2026 \u2026 \u2026 \u2026 \u2026 <p>You can run an enrichment on one specific aspect:</p> <p>We have three aspects we can search, cellular component (cc), molecular function (mf), and biological process (bp). More detail on gene ontology aspects can be found here.</p> <pre><code># Perform the GO enrichment analysis searching on the cellular component aspect:\nresults = gopher.test_enrichment(proteins=quant_proteins, aspect=\"cc\")\n</code></pre> <p>Or on a subset of terms:</p> <pre><code>terms = [\n    \"cytoplasm\",\n    \"nucleus\",\n    \"cell surface\",\n    \"protein folding\",\n    \"dna repair\"\n]\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=quant_proteins, go_subset=terms)\n</code></pre> <p>If you search a subset of terms, the DAG algorithm will run to aggregate all child terms of the terms of interest.</p> <p>The DAG algorithm is a hybrid depth-first search and breadth-first search. The algorithm will find the first child of the term of interest and then find all it\u2019s children and grandchildren until it finds all descendants from than child. It will and annotate those descendants with the term of interest and go to the next child of the term of interest and repeat until all descendants have been annotated. If a child term is also a term of interest, it does not get aggregated into the other term. If two terms of interest share a child, the child is annotated by both terms.</p> <p></p> <p>You can turn this off using the <code>aggregate_terms</code> parameter. When you turn off the <code>aggregate_terms</code> parameter, gopher only searches for proteins directly associated with the term of interest.</p> <pre><code>results = gopher.test_enrichment(proteins=quant_proteins, go_subset=terms, aggregate_terms=False)\n</code></pre> <p>If using a file where the quant values are p-values, you can rank in ascending order.</p> <p>By default, gopher ranks values by descending order, larger values will have a lower rank. The ranking order can be switched by setting the <code>desc</code> parameter to <code>False</code>.</p> <pre><code>results = gopher.test_enrichment(proteins=quant_proteins, desc=False)\n</code></pre>"},{"location":"examples/#file-parsers","title":"File parsers","text":"<p>Gopher can format an encyclopeDIA and metamorpheus file for the enrichment</p> <p>The output of encyclopeDIA and metamorpheus can be directly inputed to gopher using the <code>read_encyclopedia</code> and <code>read_metamorpheus</code> functions. These functions will format the data for the enrichment.</p> <pre><code># Read data from an EncyclopeDIA output:\nproteins = gopher.read_encyclopedia(\"results.quant.elib.proteins.txt\")\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=proteins)\n</code></pre>"},{"location":"examples/#normalization","title":"Normalization","text":"<p>If raw intensities are used, you can normalize your data using the proteomic ruler approach (Wi\u015bniewski JR, et al, 2014). This approach is built off the following equations presented in the proteomic ruler paper:</p> <p> </p> <pre><code># Normalize the raw intensities\nnormalized_proteins = gopher.normalize_values(quant_proteins, \"human_fasta.fasta\")\n\n# Peform the GO enrichment analysis:\nresults = gopher.test_enrichment(proteins=normalized_proteins)\n</code></pre>"},{"location":"vignettes/","title":"Enrichment vignette","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport gopher\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> import pandas as pd import gopher import matplotlib.pyplot as plt import seaborn as sns import numpy as np import warnings warnings.filterwarnings('ignore') <p>Read the input file. This data comes from a FAK knockout dataset (Table S1) from  Koide E, et al. 2023.</p> In\u00a0[2]: Copied! <pre>df = pd.read_csv(\"static/prot_quant.txt\", sep='\\t')\ndf.head()\n</pre> df = pd.read_csv(\"static/prot_quant.txt\", sep='\\t') df.head() Out[2]: ID Protein logFC AveExpr t P.Value adj.P.Val B 0 Q05397 PTK2 -2.859883 2.340355 -99.425405 1.060000e-11 8.690000e-08 12.498542 1 Q15418-2 RPS6KA1 -0.932924 3.128221 -19.062544 5.290000e-07 1.081399e-03 6.609119 2 O14965 AURKA -0.650304 3.160873 -19.699383 4.270000e-07 1.081399e-03 6.437053 3 P51948-1 MNAT1 -0.500882 3.227122 -14.454300 3.140000e-06 5.143099e-03 4.712882 4 Q9BYT3-1 STK33 -2.075020 2.675332 -27.269400 5.150000e-08 2.106740e-04 4.557334 <p>For gopher we need to reformat the data so the index is the UniProtKB accessions and the columns are the quantitative values we want to test. Since this data has statstic information, we choose the value we want to test. I am choosing <code>ad.P.Val</code> here.</p> In\u00a0[3]: Copied! <pre>input_df = df[[\"ID\", \"adj.P.Val\"]].set_index(\"ID\")\ninput_df.head()\n</pre> input_df = df[[\"ID\", \"adj.P.Val\"]].set_index(\"ID\") input_df.head() Out[3]: adj.P.Val ID Q05397 8.690000e-08 Q15418-2 1.081399e-03 O14965 1.081399e-03 P51948-1 5.143099e-03 Q9BYT3-1 2.106740e-04 <p>Next I choose the terms I want to search. I am choosing some terms I expect to be enriched in this dataset and some that I do not expect to be enriched. This is optional, you can search all terms.</p> In\u00a0[4]: Copied! <pre>terms = [\n    # should NOT be enriched\n    \"membrane organization\",\n    \"protein folding\",\n    \"transcription regulator activity\",\n    # SHOULD be enriched\n    \"cell adhesion\",\n    \"anatomical structure development\",\n    \"cell motility\",\n    \"cell differentiation\",\n    \"protein phosphorylation\",\n    \"protein autophosphorylation\"\n]\n</pre> terms = [     # should NOT be enriched     \"membrane organization\",     \"protein folding\",     \"transcription regulator activity\",     # SHOULD be enriched     \"cell adhesion\",     \"anatomical structure development\",     \"cell motility\",     \"cell differentiation\",     \"protein phosphorylation\",     \"protein autophosphorylation\" ] <p>Run the enrichment on the data with the terms of interest. I also set the descending flag to <code>False</code> since we want the lower (more significant) p-values to be ranked lower.</p> In\u00a0[5]: Copied! <pre>results = gopher.test_enrichment(input_df, go_subset=terms, desc=False)\nresults.head()\n</pre> results = gopher.test_enrichment(input_df, go_subset=terms, desc=False) results.head() <pre>OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</pre> Out[5]: GO ID GO Name GO Aspect adj.P.Val 0 GO:0006457 protein folding P 0.987289 1 GO:0006468 protein phosphorylation P 0.072794 2 GO:0007155 cell adhesion P 0.848735 3 GO:0030154 cell differentiation P 0.267482 4 GO:0046777 protein autophosphorylation P 0.069585 <p>To visualize the data, we reformat the data and plot the -log10(p-value).</p> In\u00a0[6]: Copied! <pre>long_df = results.melt(\n    [\"GO ID\", \"GO Name\", \"GO Aspect\"],\n    var_name=\"Run\",\n    value_name=\"pvalue\",\n)\nlong_df[\"neglogpval\"] = -np.log10(long_df[\"pvalue\"])\n</pre> long_df = results.melt(     [\"GO ID\", \"GO Name\", \"GO Aspect\"],     var_name=\"Run\",     value_name=\"pvalue\", ) long_df[\"neglogpval\"] = -np.log10(long_df[\"pvalue\"]) In\u00a0[7]: Copied! <pre>sns.barplot(\n    long_df.sort_values(by=\"neglogpval\"),\n    x=\"GO Name\",\n    y=\"neglogpval\",\n    hue=\"Run\",\n)\nplt.ylabel(\"-log10(pval)\")\nplt.xticks(rotation=90)\nplt.show()\n</pre> sns.barplot(     long_df.sort_values(by=\"neglogpval\"),     x=\"GO Name\",     y=\"neglogpval\",     hue=\"Run\", ) plt.ylabel(\"-log10(pval)\") plt.xticks(rotation=90) plt.show() <p>If I want to further investigate a term, I can by looking at the protein rankings of that term.</p> In\u00a0[8]: Copied! <pre>ranks = gopher.get_rankings(input_df, \"cell motility\")\nranks.head()\n</pre> ranks = gopher.get_rankings(input_df, \"cell motility\") ranks.head() Out[8]: adj.P.Val in_term ID Q05397 1.0 True Q15418-2 3.5 False P51948-1 5.0 False Q9BYT3-1 2.0 False P51946 6.0 False In\u00a0[9]: Copied! <pre>in_term = ranks[ranks[\"in_term\"]]\nsns.kdeplot(in_term[\"adj.P.Val\"], label=\"In term\")\nout_term = ranks[~ranks[\"in_term\"]]\nsns.kdeplot(out_term[\"adj.P.Val\"], label=\"Not in term\")\nplt.xlabel(\"Rankings\")\nplt.legend()\nplt.show()\n</pre> in_term = ranks[ranks[\"in_term\"]] sns.kdeplot(in_term[\"adj.P.Val\"], label=\"In term\") out_term = ranks[~ranks[\"in_term\"]] sns.kdeplot(out_term[\"adj.P.Val\"], label=\"Not in term\") plt.xlabel(\"Rankings\") plt.legend() plt.show()"},{"location":"vignettes/#enrichment-vignette","title":"Enrichment vignette\u00b6","text":"<p>First, import required packages.</p>"}]}